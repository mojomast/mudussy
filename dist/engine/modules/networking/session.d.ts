import { EventEmitter } from 'events';
import { Socket } from 'net';
import { EventSystem } from '../../core/event';
import { ISession, SessionState, IAuthResult, INetworkConfig, UserRole } from './types';
export declare class SessionManager extends EventEmitter {
    private sessions;
    private eventSystem;
    private config;
    private idleTimeouts;
    private rateLimitData;
    private logger;
    constructor(eventSystem: EventSystem, config: INetworkConfig, logger?: any);
    createSession(socket: Socket): ISession;
    getSession(sessionId: string): ISession | undefined;
    getAllSessions(): ISession[];
    getSessionsByState(state: SessionState): ISession[];
    getSessionCount(): number;
    updateActivity(sessionId: string): void;
    authenticateSession(sessionId: string, username: string, password: string, userId?: string, role?: UserRole): Promise<IAuthResult>;
    loadPersistentSession(sessionId: string, userId: string): Promise<boolean>;
    savePersistentSession(sessionId: string): Promise<void>;
    restorePersistentSession(sessionId: string, persistentData: any): Promise<boolean>;
    disconnectSession(sessionId: string, reason?: string): void;
    sendToSession(sessionId: string, content: string, type?: 'system' | 'user' | 'error' | 'info' | 'broadcast'): boolean;
    broadcastMessage(content: string, type?: 'system' | 'user' | 'error' | 'info' | 'broadcast', excludeSessionId?: string): void;
    isRateLimited(sessionId: string): boolean;
    private setupSocketHandlers;
    private handleSocketData;
    private handleTelnetCommands;
    private processTelnetCommand;
    private handleTelnetOption;
    private handleUserInput;
    private handleSocketClose;
    private handleSocketError;
    private handleSocketTimeout;
    private removeSession;
    private startIdleTimeout;
    private resetIdleTimeout;
    private clearIdleTimeout;
    private handleIdleTimeout;
    private getSessionInfo;
    private cleanup;
    getStatistics(): any;
}
